--- net/minecraft/src/Tessellator.java
+++ net/minecraft/src/Tessellator.java
@@ -1,311 +1,296 @@
 package net.minecraft.src;
 
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
 import org.lwjgl.opengl.ARBVertexBufferObject;
 import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL15;
 import org.lwjgl.opengl.GLContext;
 
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
 public class Tessellator {
+
+    public static final Tessellator instance = new Tessellator(0x200000);
     private static boolean convertQuadsToTriangles = true;
     private static boolean tryVBO = false;
     private ByteBuffer byteBuffer;
     private IntBuffer intBuffer;
     private FloatBuffer floatBuffer;
-    private int[] rawBuffer;
-    private int vertexCount = 0;
+    private int rawBuffer[];
+    private int vertexCount;
     private double textureU;
     private double textureV;
     private int color;
-    private boolean hasColor = false;
-    private boolean hasTexture = false;
-    private boolean hasNormals = false;
-    private int rawBufferIndex = 0;
-    private int addedVertices = 0;
-    private boolean isColorDisabled = false;
+    private boolean hasColor;
+    private boolean hasTexture;
+    private boolean hasNormals;
+    private int rawBufferIndex;
+    private int addedVertices;
+    private boolean isColorDisabled;
     private int drawMode;
     private double xOffset;
     private double yOffset;
     private double zOffset;
     private int normal;
-    public static final Tessellator instance = new Tessellator(2097152);
-    private boolean isDrawing = false;
-    private boolean useVBO = false;
+    private boolean isDrawing;
+    private boolean useVBO;
     private IntBuffer vertexBuffers;
-    private int vboIndex = 0;
-    private int vboCount = 10;
+    private int vboIndex;
+    private int vboCount;
     private int bufferSize;
-
-    private Tessellator(int var1) {
-        this.bufferSize = var1;
-        this.byteBuffer = GLAllocation.createDirectByteBuffer(var1 * 4);
-        this.intBuffer = this.byteBuffer.asIntBuffer();
-        this.floatBuffer = this.byteBuffer.asFloatBuffer();
-        this.rawBuffer = new int[var1];
-        this.useVBO = tryVBO && GLContext.getCapabilities().GL_ARB_vertex_buffer_object;
-        if(this.useVBO) {
-            this.vertexBuffers = GLAllocation.createDirectIntBuffer(this.vboCount);
-            ARBVertexBufferObject.glGenBuffersARB(this.vertexBuffers);
+    private Tessellator(int i) {
+        vertexCount = 0;
+        hasColor = false;
+        hasTexture = false;
+        hasNormals = false;
+        rawBufferIndex = 0;
+        addedVertices = 0;
+        isColorDisabled = false;
+        isDrawing = false;
+        useVBO = false;
+        vboIndex = 0;
+        vboCount = 10;
+        bufferSize = i;
+        byteBuffer = GLAllocation.createDirectByteBuffer(i * 4);
+        intBuffer = byteBuffer.asIntBuffer();
+        floatBuffer = byteBuffer.asFloatBuffer();
+        rawBuffer = new int[i];
+        useVBO = tryVBO && GLContext.getCapabilities().GL_ARB_vertex_buffer_object;
+        if (useVBO) {
+            vertexBuffers = GLAllocation.createDirectIntBuffer(vboCount);
+            ARBVertexBufferObject.glGenBuffersARB(vertexBuffers);
         }
-
     }
 
     public void draw() {
-        if(!this.isDrawing) {
+        if (!isDrawing) {
             throw new IllegalStateException("Not tesselating!");
-        } else {
-            this.isDrawing = false;
-            if(this.vertexCount > 0) {
-                this.intBuffer.clear();
-                this.intBuffer.put(this.rawBuffer, 0, this.rawBufferIndex);
-                this.byteBuffer.position(0);
-                this.byteBuffer.limit(this.rawBufferIndex * 4);
-                if(this.useVBO) {
-                    this.vboIndex = (this.vboIndex + 1) % this.vboCount;
-                    ARBVertexBufferObject.glBindBufferARB(GL15.GL_ARRAY_BUFFER, this.vertexBuffers.get(this.vboIndex));
-                    ARBVertexBufferObject.glBufferDataARB(GL15.GL_ARRAY_BUFFER, this.byteBuffer, GL15.GL_STREAM_DRAW);
-                }
-
-                if(this.hasTexture) {
-                    if(this.useVBO) {
-                        GL11.glTexCoordPointer(2, GL11.GL_FLOAT, 32, 12L);
-                    } else {
-                        this.floatBuffer.position(3);
-                        GL11.glTexCoordPointer(2, 32, (FloatBuffer)this.floatBuffer);
-                    }
-
-                    GL11.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
-                }
-
-                if(this.hasColor) {
-                    if(this.useVBO) {
-                        GL11.glColorPointer(4, GL11.GL_UNSIGNED_BYTE, 32, 20L);
-                    } else {
-                        this.byteBuffer.position(20);
-                        GL11.glColorPointer(4, true, 32, this.byteBuffer);
-                    }
-
-                    GL11.glEnableClientState(GL11.GL_COLOR_ARRAY);
-                }
-
-                if(this.hasNormals) {
-                    if(this.useVBO) {
-                        GL11.glNormalPointer(GL11.GL_BYTE, 32, 24L);
-                    } else {
-                        this.byteBuffer.position(24);
-                        GL11.glNormalPointer(32, (ByteBuffer)this.byteBuffer);
-                    }
-
-                    GL11.glEnableClientState(GL11.GL_NORMAL_ARRAY);
-                }
-
-                if(this.useVBO) {
-                    GL11.glVertexPointer(3, GL11.GL_FLOAT, 32, 0L);
-                } else {
-                    this.floatBuffer.position(0);
-                    GL11.glVertexPointer(3, 32, (FloatBuffer)this.floatBuffer);
-                }
-
-                GL11.glEnableClientState(GL11.GL_VERTEX_ARRAY);
-                if(this.drawMode == 7 && convertQuadsToTriangles) {
-                    GL11.glDrawArrays(GL11.GL_TRIANGLES, GL11.GL_POINTS, this.vertexCount);
-                } else {
-                    GL11.glDrawArrays(this.drawMode, GL11.GL_POINTS, this.vertexCount);
-                }
-
-                GL11.glDisableClientState(GL11.GL_VERTEX_ARRAY);
-                if(this.hasTexture) {
-                    GL11.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
-                }
-
-                if(this.hasColor) {
-                    GL11.glDisableClientState(GL11.GL_COLOR_ARRAY);
-                }
-
-                if(this.hasNormals) {
-                    GL11.glDisableClientState(GL11.GL_NORMAL_ARRAY);
-                }
-            }
-
-            this.reset();
-        }
+        }
+        isDrawing = false;
+        if (vertexCount > 0) {
+            intBuffer.clear();
+            intBuffer.put(rawBuffer, 0, rawBufferIndex);
+            byteBuffer.position(0);
+            byteBuffer.limit(rawBufferIndex * 4);
+            if (useVBO) {
+                vboIndex = (vboIndex + 1) % vboCount;
+                ARBVertexBufferObject.glBindBufferARB(34962, vertexBuffers.get(vboIndex));
+                ARBVertexBufferObject.glBufferDataARB(34962, byteBuffer, 35040);
+            }
+            if (hasTexture) {
+                if (useVBO) {
+                    GL11.glTexCoordPointer(2, 5126, 32, 12L);
+                } else {
+                    floatBuffer.position(3);
+                    GL11.glTexCoordPointer(2, 32, floatBuffer);
+                }
+                GL11.glEnableClientState(32888);
+            }
+            if (hasColor) {
+                if (useVBO) {
+                    GL11.glColorPointer(4, 5121, 32, 20L);
+                } else {
+                    byteBuffer.position(20);
+                    GL11.glColorPointer(4, true, 32, byteBuffer);
+                }
+                GL11.glEnableClientState(32886);
+            }
+            if (hasNormals) {
+                if (useVBO) {
+                    GL11.glNormalPointer(5120, 32, 24L);
+                } else {
+                    byteBuffer.position(24);
+                    GL11.glNormalPointer(32, byteBuffer);
+                }
+                GL11.glEnableClientState(32885);
+            }
+            if (useVBO) {
+                GL11.glVertexPointer(3, 5126, 32, 0L);
+            } else {
+                floatBuffer.position(0);
+                GL11.glVertexPointer(3, 32, floatBuffer);
+            }
+            GL11.glEnableClientState(32884);
+            if (drawMode == 7 && convertQuadsToTriangles) {
+                GL11.glDrawArrays(4, 0, vertexCount);
+            } else {
+                GL11.glDrawArrays(drawMode, 0, vertexCount);
+            }
+            GL11.glDisableClientState(32884);
+            if (hasTexture) {
+                GL11.glDisableClientState(32888);
+            }
+            if (hasColor) {
+                GL11.glDisableClientState(32886);
+            }
+            if (hasNormals) {
+                GL11.glDisableClientState(32885);
+            }
+        }
+        reset();
     }
 
     private void reset() {
-        this.vertexCount = 0;
-        this.byteBuffer.clear();
-        this.rawBufferIndex = 0;
-        this.addedVertices = 0;
+        vertexCount = 0;
+        byteBuffer.clear();
+        rawBufferIndex = 0;
+        addedVertices = 0;
     }
 
     public void startDrawingQuads() {
-        this.startDrawing(7);
+        startDrawing(7);
     }
 
-    public void startDrawing(int var1) {
-        if(this.isDrawing) {
+    public void startDrawing(int i) {
+        if (isDrawing) {
             throw new IllegalStateException("Already tesselating!");
         } else {
-            this.isDrawing = true;
-            this.reset();
-            this.drawMode = var1;
-            this.hasNormals = false;
-            this.hasColor = false;
-            this.hasTexture = false;
-            this.isColorDisabled = false;
-        }
-    }
-
-    public void setTextureUV(double var1, double var3) {
-        this.hasTexture = true;
-        this.textureU = var1;
-        this.textureV = var3;
-    }
-
-    public void setColorOpaque_F(float var1, float var2, float var3) {
-        this.setColorOpaque((int)(var1 * 255.0F), (int)(var2 * 255.0F), (int)(var3 * 255.0F));
-    }
-
-    public void setColorRGBA_F(float var1, float var2, float var3, float var4) {
-        this.setColorRGBA((int)(var1 * 255.0F), (int)(var2 * 255.0F), (int)(var3 * 255.0F), (int)(var4 * 255.0F));
-    }
-
-    public void setColorOpaque(int var1, int var2, int var3) {
-        this.setColorRGBA(var1, var2, var3, 255);
-    }
-
-    public void setColorRGBA(int var1, int var2, int var3, int var4) {
-        if(!this.isColorDisabled) {
-            if(var1 > 255) {
-                var1 = 255;
-            }
-
-            if(var2 > 255) {
-                var2 = 255;
-            }
-
-            if(var3 > 255) {
-                var3 = 255;
-            }
-
-            if(var4 > 255) {
-                var4 = 255;
-            }
-
-            if(var1 < 0) {
-                var1 = 0;
-            }
-
-            if(var2 < 0) {
-                var2 = 0;
-            }
-
-            if(var3 < 0) {
-                var3 = 0;
-            }
-
-            if(var4 < 0) {
-                var4 = 0;
-            }
-
-            this.hasColor = true;
-            this.color = var4 << 24 | var3 << 16 | var2 << 8 | var1;
-        }
-    }
-
-    public void addVertexWithUV(double var1, double var3, double var5, double var7, double var9) {
-        this.setTextureUV(var7, var9);
-        this.addVertex(var1, var3, var5);
-    }
-
-    public void addVertex(double var1, double var3, double var5) {
-        ++this.addedVertices;
-        if(this.drawMode == 7 && convertQuadsToTriangles && this.addedVertices % 4 == 0) {
-            for(int var7 = 0; var7 < 2; ++var7) {
-                int var8 = 8 * (3 - var7);
-                if(this.hasTexture) {
-                    this.rawBuffer[this.rawBufferIndex + 3] = this.rawBuffer[this.rawBufferIndex - var8 + 3];
-                    this.rawBuffer[this.rawBufferIndex + 4] = this.rawBuffer[this.rawBufferIndex - var8 + 4];
-                }
-
-                if(this.hasColor) {
-                    this.rawBuffer[this.rawBufferIndex + 5] = this.rawBuffer[this.rawBufferIndex - var8 + 5];
-                }
-
-                this.rawBuffer[this.rawBufferIndex + 0] = this.rawBuffer[this.rawBufferIndex - var8 + 0];
-                this.rawBuffer[this.rawBufferIndex + 1] = this.rawBuffer[this.rawBufferIndex - var8 + 1];
-                this.rawBuffer[this.rawBufferIndex + 2] = this.rawBuffer[this.rawBufferIndex - var8 + 2];
-                ++this.vertexCount;
-                this.rawBufferIndex += 8;
-            }
-        }
-
-        if(this.hasTexture) {
-            this.rawBuffer[this.rawBufferIndex + 3] = Float.floatToRawIntBits((float)this.textureU);
-            this.rawBuffer[this.rawBufferIndex + 4] = Float.floatToRawIntBits((float)this.textureV);
-        }
-
-        if(this.hasColor) {
-            this.rawBuffer[this.rawBufferIndex + 5] = this.color;
-        }
-
-        if(this.hasNormals) {
-            this.rawBuffer[this.rawBufferIndex + 6] = this.normal;
-        }
-
-        this.rawBuffer[this.rawBufferIndex + 0] = Float.floatToRawIntBits((float)(var1 + this.xOffset));
-        this.rawBuffer[this.rawBufferIndex + 1] = Float.floatToRawIntBits((float)(var3 + this.yOffset));
-        this.rawBuffer[this.rawBufferIndex + 2] = Float.floatToRawIntBits((float)(var5 + this.zOffset));
-        this.rawBufferIndex += 8;
-        ++this.vertexCount;
-        if(this.vertexCount % 4 == 0 && this.rawBufferIndex >= this.bufferSize - 32) {
-            this.draw();
-            this.isDrawing = true;
-        }
-
-    }
-
-    public void setColorOpaque_I(int var1) {
-        int var2 = var1 >> 16 & 255;
-        int var3 = var1 >> 8 & 255;
-        int var4 = var1 & 255;
-        this.setColorOpaque(var2, var3, var4);
-    }
-
-    public void setColorRGBA_I(int var1, int var2) {
-        int var3 = var1 >> 16 & 255;
-        int var4 = var1 >> 8 & 255;
-        int var5 = var1 & 255;
-        this.setColorRGBA(var3, var4, var5, var2);
+            isDrawing = true;
+            reset();
+            drawMode = i;
+            hasNormals = false;
+            hasColor = false;
+            hasTexture = false;
+            isColorDisabled = false;
+            return;
+        }
+    }
+
+    public void setTextureUV(double d, double d1) {
+        hasTexture = true;
+        textureU = d;
+        textureV = d1;
+    }
+
+    public void setColorOpaque_F(float f, float f1, float f2) {
+        setColorOpaque((int) (f * 255F), (int) (f1 * 255F), (int) (f2 * 255F));
+    }
+
+    public void setColorRGBA_F(float f, float f1, float f2, float f3) {
+        setColorRGBA((int) (f * 255F), (int) (f1 * 255F), (int) (f2 * 255F), (int) (f3 * 255F));
+    }
+
+    public void setColorOpaque(int i, int j, int k) {
+        setColorRGBA(i, j, k, 255);
+    }
+
+    public void setColorRGBA(int i, int j, int k, int l) {
+        if (isColorDisabled) {
+            return;
+        }
+        if (i > 255) {
+            i = 255;
+        }
+        if (j > 255) {
+            j = 255;
+        }
+        if (k > 255) {
+            k = 255;
+        }
+        if (l > 255) {
+            l = 255;
+        }
+        if (i < 0) {
+            i = 0;
+        }
+        if (j < 0) {
+            j = 0;
+        }
+        if (k < 0) {
+            k = 0;
+        }
+        if (l < 0) {
+            l = 0;
+        }
+        hasColor = true;
+        color = l << 24 | k << 16 | j << 8 | i;
+    }
+
+    public void addVertexWithUV(double d, double d1, double d2, double d3, double d4) {
+        setTextureUV(d3, d4);
+        addVertex(d, d1, d2);
+    }
+
+    public void addVertex(double d, double d1, double d2) {
+        addedVertices++;
+        if (drawMode == 7 && convertQuadsToTriangles && addedVertices % 4 == 0) {
+            for (int i = 0; i < 2; i++) {
+                int j = 8 * (3 - i);
+                if (hasTexture) {
+                    rawBuffer[rawBufferIndex + 3] = rawBuffer[(rawBufferIndex - j) + 3];
+                    rawBuffer[rawBufferIndex + 4] = rawBuffer[(rawBufferIndex - j) + 4];
+                }
+                if (hasColor) {
+                    rawBuffer[rawBufferIndex + 5] = rawBuffer[(rawBufferIndex - j) + 5];
+                }
+                rawBuffer[rawBufferIndex + 0] = rawBuffer[(rawBufferIndex - j) + 0];
+                rawBuffer[rawBufferIndex + 1] = rawBuffer[(rawBufferIndex - j) + 1];
+                rawBuffer[rawBufferIndex + 2] = rawBuffer[(rawBufferIndex - j) + 2];
+                vertexCount++;
+                rawBufferIndex += 8;
+            }
+
+        }
+        if (hasTexture) {
+            rawBuffer[rawBufferIndex + 3] = Float.floatToRawIntBits((float) textureU);
+            rawBuffer[rawBufferIndex + 4] = Float.floatToRawIntBits((float) textureV);
+        }
+        if (hasColor) {
+            rawBuffer[rawBufferIndex + 5] = color;
+        }
+        if (hasNormals) {
+            rawBuffer[rawBufferIndex + 6] = normal;
+        }
+        rawBuffer[rawBufferIndex + 0] = Float.floatToRawIntBits((float) (d + xOffset));
+        rawBuffer[rawBufferIndex + 1] = Float.floatToRawIntBits((float) (d1 + yOffset));
+        rawBuffer[rawBufferIndex + 2] = Float.floatToRawIntBits((float) (d2 + zOffset));
+        rawBufferIndex += 8;
+        vertexCount++;
+        if (vertexCount % 4 == 0 && rawBufferIndex >= bufferSize - 32) {
+            draw();
+            isDrawing = true;
+        }
+    }
+
+    public void setColorOpaque_I(int i) {
+        int j = i >> 16 & 0xff;
+        int k = i >> 8 & 0xff;
+        int l = i & 0xff;
+        setColorOpaque(j, k, l);
+    }
+
+    public void setColorRGBA_I(int i, int j) {
+        int k = i >> 16 & 0xff;
+        int l = i >> 8 & 0xff;
+        int i1 = i & 0xff;
+        setColorRGBA(k, l, i1, j);
     }
 
     public void disableColor() {
-        this.isColorDisabled = true;
+        isColorDisabled = true;
     }
 
-    public void setNormal(float var1, float var2, float var3) {
-        if(!this.isDrawing) {
+    public void setNormal(float f, float f1, float f2) {
+        if (!isDrawing) {
             System.out.println("But..");
         }
-
-        this.hasNormals = true;
-        byte var4 = (byte)((int)(var1 * 128.0F));
-        byte var5 = (byte)((int)(var2 * 127.0F));
-        byte var6 = (byte)((int)(var3 * 127.0F));
-        this.normal = var4 | var5 << 8 | var6 << 16;
-    }
-
-    public void setTranslationD(double var1, double var3, double var5) {
-        this.xOffset = var1;
-        this.yOffset = var3;
-        this.zOffset = var5;
-    }
-
-    public void setTranslationF(float var1, float var2, float var3) {
-        this.xOffset += (double)var1;
-        this.yOffset += (double)var2;
-        this.zOffset += (double)var3;
-    }
+        hasNormals = true;
+        byte byte0 = (byte) (int) (f * 128F);
+        byte byte1 = (byte) (int) (f1 * 127F);
+        byte byte2 = (byte) (int) (f2 * 127F);
+        normal = byte0 | byte1 << 8 | byte2 << 16;
+    }
+
+    public void setTranslationD(double d, double d1, double d2) {
+        xOffset = d;
+        yOffset = d1;
+        zOffset = d2;
+    }
+
+    public void setTranslationF(float f, float f1, float f2) {
+        xOffset += f;
+        yOffset += f1;
+        zOffset += f2;
+    }
+
 }
