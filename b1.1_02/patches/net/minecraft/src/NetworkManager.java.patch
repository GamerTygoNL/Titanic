--- net/minecraft/src/NetworkManager.java
+++ net/minecraft/src/NetworkManager.java
@@ -1,5 +1,8 @@
 package net.minecraft.src;
 
+import cc.noxiuam.titanic.Ref;
+import cc.noxiuam.titanic.event.impl.network.PacketReceivedEvent;
+
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -10,195 +13,194 @@
 import java.util.List;
 
 public class NetworkManager {
+
     public static final Object threadSyncObject = new Object();
     public static int numReadThreads;
     public static int numWriteThreads;
-    private Object sendQueueLock = new Object();
-    private Socket field_12258_e;
     private final SocketAddress networkSocket;
+    public int chunkDataSendCounter;
+    private Object sendQueueLock;
+    private Socket field_12258_e;
     private DataInputStream socketInputStream;
     private DataOutputStream socketOutputStream;
-    private boolean isRunning = true;
-    private List readPackets = Collections.synchronizedList(new ArrayList());
-    private List dataPackets = Collections.synchronizedList(new ArrayList());
-    private List chunkDataPackets = Collections.synchronizedList(new ArrayList());
+    private boolean isRunning;
+    private List readPackets;
+    private List dataPackets;
+    private List chunkDataPackets;
     private NetHandler netHandler;
-    private boolean isServerTerminating = false;
+    private boolean isServerTerminating;
     private Thread writeThread;
     private Thread readThread;
-    private boolean isTerminating = false;
-    private String terminationReason = "";
-    private Object[] field_20101_t;
-    private int timeSinceLastRead = 0;
-    private int sendQueueByteLength = 0;
-    public int chunkDataSendCounter = 0;
-    private int field_20100_w = 0;
-
-    public NetworkManager(Socket var1, String var2, NetHandler var3) throws IOException {
-        this.field_12258_e = var1;
-        this.networkSocket = var1.getRemoteSocketAddress();
-        this.netHandler = var3;
-        var1.setTrafficClass(24);
-        this.socketInputStream = new DataInputStream(var1.getInputStream());
-        this.socketOutputStream = new DataOutputStream(var1.getOutputStream());
-        this.readThread = new NetworkReaderThread(this, var2 + " read thread");
-        this.writeThread = new NetworkWriterThread(this, var2 + " write thread");
-        this.readThread.start();
-        this.writeThread.start();
-    }
-
-    public void addToSendQueue(Packet var1) {
-        if(!this.isServerTerminating) {
-            Object var2 = this.sendQueueLock;
-            synchronized(var2) {
-                this.sendQueueByteLength += var1.getPacketSize() + 1;
-                if(var1.isChunkDataPacket) {
-                    this.chunkDataPackets.add(var1);
-                } else {
-                    this.dataPackets.add(var1);
-                }
-
+    private boolean isTerminating;
+    private String terminationReason;
+    private Object field_20101_t[];
+    private int timeSinceLastRead;
+    private int sendQueueByteLength;
+    private int field_20100_w;
+    public NetworkManager(Socket socket, String s, NetHandler nethandler) throws IOException {
+        sendQueueLock = new Object();
+        isRunning = true;
+        readPackets = Collections.synchronizedList(new ArrayList());
+        dataPackets = Collections.synchronizedList(new ArrayList());
+        chunkDataPackets = Collections.synchronizedList(new ArrayList());
+        isServerTerminating = false;
+        isTerminating = false;
+        terminationReason = "";
+        timeSinceLastRead = 0;
+        sendQueueByteLength = 0;
+        chunkDataSendCounter = 0;
+        field_20100_w = 0;
+        field_12258_e = socket;
+        networkSocket = socket.getRemoteSocketAddress();
+        netHandler = nethandler;
+        socket.setTrafficClass(24);
+        socketInputStream = new DataInputStream(socket.getInputStream());
+        socketOutputStream = new DataOutputStream(socket.getOutputStream());
+        readThread = new NetworkReaderThread(this, (new StringBuilder()).append(s).append(" read thread").toString());
+        writeThread = new NetworkWriterThread(this, (new StringBuilder()).append(s).append(" write thread").toString());
+        readThread.start();
+        writeThread.start();
+    }
+
+    static boolean isRunning(NetworkManager networkmanager) {
+        return networkmanager.isRunning;
+    }
+
+    static boolean isServerTerminating(NetworkManager networkmanager) {
+        return networkmanager.isServerTerminating;
+    }
+
+    static void readNetworkPacket(NetworkManager networkmanager) {
+        networkmanager.readPacket();
+    }
+
+    static void sendNetworkPacket(NetworkManager networkmanager) {
+        networkmanager.sendPacket();
+    }
+
+    static Thread getReadThread(NetworkManager networkmanager) {
+        return networkmanager.readThread;
+    }
+
+    static Thread getWriteThread(NetworkManager networkmanager) {
+        return networkmanager.writeThread;
+    }
+
+    public void addToSendQueue(Packet packet) {
+        if (isServerTerminating) {
+            return;
+        }
+        synchronized (sendQueueLock) {
+            sendQueueByteLength += packet.getPacketSize() + 1;
+            if (packet.isChunkDataPacket) {
+                chunkDataPackets.add(packet);
+            } else {
+                dataPackets.add(packet);
             }
         }
     }
 
     private void sendPacket() {
         try {
-            boolean var1 = true;
-            Packet var2;
-            Object var3;
-            if(!this.dataPackets.isEmpty() && (this.chunkDataSendCounter == 0 || System.currentTimeMillis() - ((Packet)this.dataPackets.get(0)).field_20018_j >= (long)this.chunkDataSendCounter)) {
-                var1 = false;
-                var3 = this.sendQueueLock;
-                synchronized(var3) {
-                    var2 = (Packet)this.dataPackets.remove(0);
-                    this.sendQueueByteLength -= var2.getPacketSize() + 1;
-                }
-
-                Packet.writePacket(var2, this.socketOutputStream);
-            }
-
-            if((var1 || this.field_20100_w-- <= 0) && !this.chunkDataPackets.isEmpty() && (this.chunkDataSendCounter == 0 || System.currentTimeMillis() - ((Packet)this.chunkDataPackets.get(0)).field_20018_j >= (long)this.chunkDataSendCounter)) {
-                var1 = false;
-                var3 = this.sendQueueLock;
-                synchronized(var3) {
-                    var2 = (Packet)this.chunkDataPackets.remove(0);
-                    this.sendQueueByteLength -= var2.getPacketSize() + 1;
-                }
-
-                Packet.writePacket(var2, this.socketOutputStream);
-                this.field_20100_w = 50;
-            }
-
-            if(var1) {
+            boolean flag = true;
+            if (!dataPackets.isEmpty() && (chunkDataSendCounter == 0 || System.currentTimeMillis() - ((Packet) dataPackets.get(0)).field_20018_j >= (long) chunkDataSendCounter)) {
+                flag = false;
+                Packet packet;
+                synchronized (sendQueueLock) {
+                    packet = (Packet) dataPackets.remove(0);
+                    sendQueueByteLength -= packet.getPacketSize() + 1;
+                }
+                Packet.writePacket(packet, socketOutputStream);
+            }
+            if ((flag || field_20100_w-- <= 0) && !chunkDataPackets.isEmpty() && (chunkDataSendCounter == 0 || System.currentTimeMillis() - ((Packet) chunkDataPackets.get(0)).field_20018_j >= (long) chunkDataSendCounter)) {
+                flag = false;
+                Packet packet1;
+                synchronized (sendQueueLock) {
+                    packet1 = (Packet) chunkDataPackets.remove(0);
+                    sendQueueByteLength -= packet1.getPacketSize() + 1;
+                }
+                Packet.writePacket(packet1, socketOutputStream);
+                field_20100_w = 50;
+            }
+            if (flag) {
                 Thread.sleep(10L);
             }
-        } catch (InterruptedException var8) {
-        } catch (Exception var9) {
-            if(!this.isTerminating) {
-                this.onNetworkError(var9);
+        } catch (InterruptedException interruptedexception) {
+        } catch (Exception exception) {
+            if (!isTerminating) {
+                onNetworkError(exception);
             }
         }
-
     }
 
     private void readPacket() {
         try {
-            Packet var1 = Packet.readPacket(this.socketInputStream);
-            if(var1 != null) {
-                this.readPackets.add(var1);
+            Packet packet = Packet.readPacket(socketInputStream);
+            if (packet != null) {
+                readPackets.add(packet);
             } else {
-                this.networkShutdown("disconnect.endOfStream", new Object[0]);
-            }
-        } catch (Exception var2) {
-            if(!this.isTerminating) {
-                this.onNetworkError(var2);
-            }
-        }
-
-    }
-
-    private void onNetworkError(Exception var1) {
-        var1.printStackTrace();
-        this.networkShutdown("disconnect.genericReason", new Object[]{"Internal exception: " + var1.toString()});
-    }
-
-    public void networkShutdown(String var1, Object... var2) {
-        if(this.isRunning) {
-            this.isTerminating = true;
-            this.terminationReason = var1;
-            this.field_20101_t = var2;
-            (new NetworkMasterThread(this)).start();
-            this.isRunning = false;
-
-            try {
-                this.socketInputStream.close();
-                this.socketInputStream = null;
-            } catch (Throwable var6) {
-            }
-
-            try {
-                this.socketOutputStream.close();
-                this.socketOutputStream = null;
-            } catch (Throwable var5) {
-            }
-
-            try {
-                this.field_12258_e.close();
-                this.field_12258_e = null;
-            } catch (Throwable var4) {
-            }
-
+                networkShutdown("disconnect.endOfStream", new Object[0]);
+            }
+        } catch (Exception exception) {
+            if (!isTerminating) {
+                onNetworkError(exception);
+            }
+        }
+    }
+
+    private void onNetworkError(Exception exception) {
+        exception.printStackTrace();
+        networkShutdown("disconnect.genericReason", new Object[]{
+                (new StringBuilder()).append("Internal exception: ").append(exception.toString()).toString()
+        });
+    }
+
+    public void networkShutdown(String s, Object aobj[]) {
+        if (!isRunning) {
+            return;
+        }
+        isTerminating = true;
+        terminationReason = s;
+        field_20101_t = aobj;
+        (new NetworkMasterThread(this)).start();
+        isRunning = false;
+        try {
+            socketInputStream.close();
+            socketInputStream = null;
+        } catch (Throwable throwable) {
+        }
+        try {
+            socketOutputStream.close();
+            socketOutputStream = null;
+        } catch (Throwable throwable1) {
+        }
+        try {
+            field_12258_e.close();
+            field_12258_e = null;
+        } catch (Throwable throwable2) {
         }
     }
 
     public void processReadPackets() {
-        if(this.sendQueueByteLength > 1048576) {
-            this.networkShutdown("disconnect.overflow", new Object[0]);
+        if (sendQueueByteLength > 0x100000) {
+            networkShutdown("disconnect.overflow", new Object[0]);
         }
-
-        if(this.readPackets.isEmpty()) {
-            if(this.timeSinceLastRead++ == 1200) {
-                this.networkShutdown("disconnect.timeout", new Object[0]);
+        if (readPackets.isEmpty()) {
+            if (timeSinceLastRead++ == 1200) {
+                networkShutdown("disconnect.timeout", new Object[0]);
             }
         } else {
-            this.timeSinceLastRead = 0;
-        }
-
-        int var1 = 100;
-
-        while(!this.readPackets.isEmpty() && var1-- >= 0) {
-            Packet var2 = (Packet)this.readPackets.remove(0);
-            var2.processPacket(this.netHandler);
-        }
-
-        if(this.isTerminating && this.readPackets.isEmpty()) {
-            this.netHandler.handleErrorMessage(this.terminationReason, this.field_20101_t);
-        }
-
-    }
-
-    static boolean isRunning(NetworkManager var0) {
-        return var0.isRunning;
-    }
-
-    static boolean isServerTerminating(NetworkManager var0) {
-        return var0.isServerTerminating;
-    }
-
-    static void readNetworkPacket(NetworkManager var0) {
-        var0.readPacket();
-    }
-
-    static void sendNetworkPacket(NetworkManager var0) {
-        var0.sendPacket();
-    }
-
-    static Thread getReadThread(NetworkManager var0) {
-        return var0.readThread;
-    }
-
-    static Thread getWriteThread(NetworkManager var0) {
-        return var0.writeThread;
-    }
+            timeSinceLastRead = 0;
+        }
+        Packet packet;
+        for (int i = 100; !readPackets.isEmpty() && i-- >= 0; packet.processPacket(netHandler)) {
+            packet = (Packet) readPackets.remove(0);
+            Ref.getEventManager().handleEvent(new PacketReceivedEvent(packet));
+        }
+
+        if (isTerminating && readPackets.isEmpty()) {
+            netHandler.handleErrorMessage(terminationReason, field_20101_t);
+        }
+    }
+
 }
