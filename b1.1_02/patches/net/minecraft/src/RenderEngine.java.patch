--- net/minecraft/src/RenderEngine.java
+++ net/minecraft/src/RenderEngine.java
@@ -1,8 +1,10 @@
 package net.minecraft.src;
 
-import java.awt.Graphics;
+import org.lwjgl.opengl.GL11;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
 import java.awt.image.BufferedImage;
-import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -10,383 +12,376 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
-import javax.imageio.ImageIO;
-import org.lwjgl.opengl.GL11;
 
 public class RenderEngine {
+
     public static boolean useMipmaps = false;
-    private HashMap textureMap = new HashMap();
-    private HashMap textureNameToImageMap = new HashMap();
-    private IntBuffer singleIntBuffer = GLAllocation.createDirectIntBuffer(1);
-    private ByteBuffer imageData = GLAllocation.createDirectByteBuffer(1048576);
-    private List field_1604_f = new ArrayList();
-    private Map urlToImageDataMap = new HashMap();
-    private GameSettings options;
-    private boolean clampTexture = false;
-    private boolean blurTexture = false;
-    private TexturePackList field_6527_k;
-
-    public RenderEngine(TexturePackList var1, GameSettings var2) {
-        this.field_6527_k = var1;
-        this.options = var2;
-    }
-
-    public int getTexture(String var1) {
-        TexturePackBase var2 = this.field_6527_k.selectedTexturePack;
-        Integer var3 = (Integer)this.textureMap.get(var1);
-        if(var3 != null) {
-            return var3.intValue();
-        } else {
-            try {
-                this.singleIntBuffer.clear();
-                GLAllocation.generateTextureNames(this.singleIntBuffer);
-                int var5 = this.singleIntBuffer.get(0);
-                if(var1.startsWith("##")) {
-                    this.setupTexture(this.unwrapImageByColumns(this.readTextureImage(var2.func_6481_a(var1.substring(2)))), var5);
-                } else if(var1.startsWith("%clamp%")) {
-                    this.clampTexture = true;
-                    this.setupTexture(this.readTextureImage(var2.func_6481_a(var1.substring(7))), var5);
-                    this.clampTexture = false;
-                } else if(var1.startsWith("%blur%")) {
-                    this.blurTexture = true;
-                    this.setupTexture(this.readTextureImage(var2.func_6481_a(var1.substring(6))), var5);
-                    this.blurTexture = false;
-                } else {
-                    this.setupTexture(this.readTextureImage(var2.func_6481_a(var1)), var5);
-                }
-
-                this.textureMap.put(var1, Integer.valueOf(var5));
-                return var5;
-            } catch (IOException var4) {
-                throw new RuntimeException("!!");
-            }
-        }
-    }
-
-    private BufferedImage unwrapImageByColumns(BufferedImage var1) {
-        int var2 = var1.getWidth() / 16;
-        BufferedImage var3 = new BufferedImage(16, var1.getHeight() * var2, 2);
-        Graphics var4 = var3.getGraphics();
-
-        for(int var5 = 0; var5 < var2; ++var5) {
-            var4.drawImage(var1, -var5 * 16, var5 * var1.getHeight(), (ImageObserver)null);
-        }
-
-        var4.dispose();
-        return var3;
-    }
-
-    public int allocateAndSetupTexture(BufferedImage var1) {
-        this.singleIntBuffer.clear();
-        GLAllocation.generateTextureNames(this.singleIntBuffer);
-        int var2 = this.singleIntBuffer.get(0);
-        this.setupTexture(var1, var2);
-        this.textureNameToImageMap.put(Integer.valueOf(var2), var1);
-        return var2;
-    }
-
-    public void setupTexture(BufferedImage var1, int var2) {
-        GL11.glBindTexture(GL11.GL_TEXTURE_2D, var2);
-        if(useMipmaps) {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-        } else {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
-        }
-
-        if(this.blurTexture) {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-        }
-
-        if(this.clampTexture) {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_CLAMP);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_CLAMP);
-        } else {
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
-        }
-
-        int var3 = var1.getWidth();
-        int var4 = var1.getHeight();
-        int[] var5 = new int[var3 * var4];
-        byte[] var6 = new byte[var3 * var4 * 4];
-        var1.getRGB(0, 0, var3, var4, var5, 0, var3);
-
-        int var7;
-        int var8;
-        int var9;
-        int var10;
-        int var11;
-        int var12;
-        int var13;
-        int var14;
-        for(var7 = 0; var7 < var5.length; ++var7) {
-            var8 = var5[var7] >> 24 & 255;
-            var9 = var5[var7] >> 16 & 255;
-            var10 = var5[var7] >> 8 & 255;
-            var11 = var5[var7] & 255;
-            if(this.options != null && this.options.anaglyph) {
-                var12 = (var9 * 30 + var10 * 59 + var11 * 11) / 100;
-                var13 = (var9 * 30 + var10 * 70) / 100;
-                var14 = (var9 * 30 + var11 * 70) / 100;
-                var9 = var12;
-                var10 = var13;
-                var11 = var14;
-            }
-
-            var6[var7 * 4 + 0] = (byte)var9;
-            var6[var7 * 4 + 1] = (byte)var10;
-            var6[var7 * 4 + 2] = (byte)var11;
-            var6[var7 * 4 + 3] = (byte)var8;
-        }
-
-        this.imageData.clear();
-        this.imageData.put(var6);
-        this.imageData.position(0).limit(var6.length);
-        GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, var3, var4, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
-        if(useMipmaps) {
-            for(var7 = 1; var7 <= 4; ++var7) {
-                var8 = var3 >> var7 - 1;
-                var9 = var3 >> var7;
-                var10 = var4 >> var7;
-
-                for(var11 = 0; var11 < var9; ++var11) {
-                    for(var12 = 0; var12 < var10; ++var12) {
-                        var13 = this.imageData.getInt((var11 * 2 + 0 + (var12 * 2 + 0) * var8) * 4);
-                        var14 = this.imageData.getInt((var11 * 2 + 1 + (var12 * 2 + 0) * var8) * 4);
-                        int var15 = this.imageData.getInt((var11 * 2 + 1 + (var12 * 2 + 1) * var8) * 4);
-                        int var16 = this.imageData.getInt((var11 * 2 + 0 + (var12 * 2 + 1) * var8) * 4);
-                        int var17 = this.weightedAverageColor(this.weightedAverageColor(var13, var14), this.weightedAverageColor(var15, var16));
-                        this.imageData.putInt((var11 + var12 * var9) * 4, var17);
+    private final HashMap textureMap;
+    private final HashMap textureNameToImageMap;
+    private final IntBuffer singleIntBuffer;
+    private final ByteBuffer imageData;
+    private final java.util.List field_1604_f;
+    private final Map urlToImageDataMap;
+    private final GameSettings options;
+    private final TexturePackList field_6527_k;
+    private boolean clampTexture;
+    private boolean blurTexture;
+
+    public RenderEngine(TexturePackList texturepacklist, GameSettings gamesettings) {
+        textureMap = new HashMap();
+        textureNameToImageMap = new HashMap();
+        singleIntBuffer = GLAllocation.createDirectIntBuffer(1);
+        imageData = GLAllocation.createDirectByteBuffer(0x100000);
+        field_1604_f = new ArrayList();
+        urlToImageDataMap = new HashMap();
+        clampTexture = false;
+        blurTexture = false;
+        field_6527_k = texturepacklist;
+        options = gamesettings;
+    }
+
+    public int getTexture(String s) {
+        TexturePackBase texturepackbase = field_6527_k.selectedTexturePack;
+        Integer integer = (Integer) textureMap.get(s);
+        if (integer != null) {
+            return integer.intValue();
+        }
+        try {
+            singleIntBuffer.clear();
+            GLAllocation.generateTextureNames(singleIntBuffer);
+            int i = singleIntBuffer.get(0);
+            if (s.startsWith("##")) {
+                setupTexture(unwrapImageByColumns(readTextureImage(texturepackbase.func_6481_a(s.substring(2)))), i);
+            } else if (s.startsWith("%clamp%")) {
+                clampTexture = true;
+                setupTexture(readTextureImage(texturepackbase.func_6481_a(s.substring(7))), i);
+                clampTexture = false;
+            } else if (s.startsWith("%blur%")) {
+                blurTexture = true;
+                setupTexture(readTextureImage(texturepackbase.func_6481_a(s.substring(6))), i);
+                blurTexture = false;
+            } else {
+                setupTexture(readTextureImage(texturepackbase.func_6481_a(s)), i);
+            }
+            textureMap.put(s, Integer.valueOf(i));
+            return i;
+        } catch (IOException ioexception) {
+            throw new RuntimeException("!!");
+        }
+    }
+
+    private BufferedImage unwrapImageByColumns(BufferedImage bufferedimage) {
+        int i = bufferedimage.getWidth() / 16;
+        BufferedImage bufferedimage1 = new BufferedImage(16, bufferedimage.getHeight() * i, 2);
+        Graphics g = bufferedimage1.getGraphics();
+        for (int j = 0; j < i; j++) {
+            g.drawImage(bufferedimage, -j * 16, j * bufferedimage.getHeight(), null);
+        }
+
+        g.dispose();
+        return bufferedimage1;
+    }
+
+    public int allocateAndSetupTexture(BufferedImage bufferedimage) {
+        singleIntBuffer.clear();
+        GLAllocation.generateTextureNames(singleIntBuffer);
+        int i = singleIntBuffer.get(0);
+        setupTexture(bufferedimage, i);
+        textureNameToImageMap.put(Integer.valueOf(i), bufferedimage);
+        return i;
+    }
+
+    public void setupTexture(BufferedImage bufferedimage, int i) {
+        GL11.glBindTexture(3553 /*GL_TEXTURE_2D*/, i);
+        if (useMipmaps) {
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10241 /*GL_TEXTURE_MIN_FILTER*/, 9987 /*GL_LINEAR_MIPMAP_LINEAR*/);
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10240 /*GL_TEXTURE_MAG_FILTER*/, 9729 /*GL_LINEAR*/);
+        } else {
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10241 /*GL_TEXTURE_MIN_FILTER*/, 9728 /*GL_NEAREST*/);
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10240 /*GL_TEXTURE_MAG_FILTER*/, 9728 /*GL_NEAREST*/);
+        }
+        if (blurTexture) {
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10241 /*GL_TEXTURE_MIN_FILTER*/, 9729 /*GL_LINEAR*/);
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10240 /*GL_TEXTURE_MAG_FILTER*/, 9729 /*GL_LINEAR*/);
+        }
+        if (clampTexture) {
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10242 /*GL_TEXTURE_WRAP_S*/, 10496 /*GL_CLAMP*/);
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10243 /*GL_TEXTURE_WRAP_T*/, 10496 /*GL_CLAMP*/);
+        } else {
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10242 /*GL_TEXTURE_WRAP_S*/, 10497 /*GL_REPEAT*/);
+            GL11.glTexParameteri(3553 /*GL_TEXTURE_2D*/, 10243 /*GL_TEXTURE_WRAP_T*/, 10497 /*GL_REPEAT*/);
+        }
+        int j = bufferedimage.getWidth();
+        int k = bufferedimage.getHeight();
+        int[] ai = new int[j * k];
+        byte[] abyte0 = new byte[j * k * 4];
+        bufferedimage.getRGB(0, 0, j, k, ai, 0, j);
+        for (int l = 0; l < ai.length; l++) {
+            int j1 = ai[l] >> 24 & 0xff;
+            int l1 = ai[l] >> 16 & 0xff;
+            int j2 = ai[l] >> 8 & 0xff;
+            int l2 = ai[l] & 0xff;
+            if (options != null && options.anaglyph) {
+                int j3 = (l1 * 30 + j2 * 59 + l2 * 11) / 100;
+                int l3 = (l1 * 30 + j2 * 70) / 100;
+                int j4 = (l1 * 30 + l2 * 70) / 100;
+                l1 = j3;
+                j2 = l3;
+                l2 = j4;
+            }
+            abyte0[l * 4] = (byte) l1;
+            abyte0[l * 4 + 1] = (byte) j2;
+            abyte0[l * 4 + 2] = (byte) l2;
+            abyte0[l * 4 + 3] = (byte) j1;
+        }
+
+        imageData.clear();
+        imageData.put(abyte0);
+        imageData.position(0).limit(abyte0.length);
+        GL11.glTexImage2D(3553 /*GL_TEXTURE_2D*/, 0, 6408 /*GL_RGBA*/, j, k, 0, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+        if (useMipmaps) {
+            for (int i1 = 1; i1 <= 4; i1++) {
+                int k1 = j >> i1 - 1;
+                int i2 = j >> i1;
+                int k2 = k >> i1;
+                for (int i3 = 0; i3 < i2; i3++) {
+                    for (int k3 = 0; k3 < k2; k3++) {
+                        int i4 = imageData.getInt((i3 * 2 + (k3 * 2) * k1) * 4);
+                        int k4 = imageData.getInt((i3 * 2 + 1 + (k3 * 2) * k1) * 4);
+                        int l4 = imageData.getInt((i3 * 2 + 1 + (k3 * 2 + 1) * k1) * 4);
+                        int i5 = imageData.getInt((i3 * 2 + (k3 * 2 + 1) * k1) * 4);
+                        int j5 = weightedAverageColor(weightedAverageColor(i4, k4), weightedAverageColor(l4, i5));
+                        imageData.putInt((i3 + k3 * i2) * 4, j5);
                     }
-                }
-
-                GL11.glTexImage2D(GL11.GL_TEXTURE_2D, var7, GL11.GL_RGBA, var9, var10, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
-            }
-        }
-
-    }
-
-    public void deleteTexture(int var1) {
-        this.textureNameToImageMap.remove(Integer.valueOf(var1));
-        this.singleIntBuffer.clear();
-        this.singleIntBuffer.put(var1);
-        this.singleIntBuffer.flip();
-        GL11.glDeleteTextures(this.singleIntBuffer);
-    }
-
-    public int getTextureForDownloadableImage(String var1, String var2) {
-        ThreadDownloadImageData var3 = (ThreadDownloadImageData)this.urlToImageDataMap.get(var1);
-        if(var3 != null && var3.image != null && !var3.textureSetupComplete) {
-            if(var3.textureName < 0) {
-                var3.textureName = this.allocateAndSetupTexture(var3.image);
-            } else {
-                this.setupTexture(var3.image, var3.textureName);
-            }
-
-            var3.textureSetupComplete = true;
-        }
-
-        return var3 != null && var3.textureName >= 0 ? var3.textureName : (var2 == null ? -1 : this.getTexture(var2));
-    }
-
-    public ThreadDownloadImageData obtainImageData(String var1, ImageBuffer var2) {
-        ThreadDownloadImageData var3 = (ThreadDownloadImageData)this.urlToImageDataMap.get(var1);
-        if(var3 == null) {
-            this.urlToImageDataMap.put(var1, new ThreadDownloadImageData(var1, var2));
-        } else {
-            ++var3.referenceCount;
-        }
-
-        return var3;
-    }
-
-    public void releaseImageData(String var1) {
-        ThreadDownloadImageData var2 = (ThreadDownloadImageData)this.urlToImageDataMap.get(var1);
-        if(var2 != null) {
-            --var2.referenceCount;
-            if(var2.referenceCount == 0) {
-                if(var2.textureName >= 0) {
-                    this.deleteTexture(var2.textureName);
-                }
-
-                this.urlToImageDataMap.remove(var1);
-            }
-        }
-
-    }
-
-    public void registerTextureFX(TextureFX var1) {
-        this.field_1604_f.add(var1);
-        var1.func_783_a();
+
+                }
+
+                GL11.glTexImage2D(3553 /*GL_TEXTURE_2D*/, i1, 6408 /*GL_RGBA*/, i2, k2, 0, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+            }
+
+        }
+    }
+
+    public void deleteTexture(int i) {
+        textureNameToImageMap.remove(Integer.valueOf(i));
+        singleIntBuffer.clear();
+        singleIntBuffer.put(i);
+        singleIntBuffer.flip();
+        GL11.glDeleteTextures(singleIntBuffer);
+    }
+
+    public int getTextureForDownloadableImage(String s, String s1) {
+        ThreadDownloadImageData threaddownloadimagedata = (ThreadDownloadImageData) urlToImageDataMap.get(s);
+        if (threaddownloadimagedata != null && threaddownloadimagedata.image != null && !threaddownloadimagedata.textureSetupComplete) {
+            if (threaddownloadimagedata.textureName < 0) {
+                threaddownloadimagedata.textureName = allocateAndSetupTexture(threaddownloadimagedata.image);
+            } else {
+                setupTexture(threaddownloadimagedata.image, threaddownloadimagedata.textureName);
+            }
+            threaddownloadimagedata.textureSetupComplete = true;
+        }
+        if (threaddownloadimagedata == null || threaddownloadimagedata.textureName < 0) {
+            if (s1 == null) {
+                return -1;
+            } else {
+                return getTexture(s1);
+            }
+        } else {
+            return threaddownloadimagedata.textureName;
+        }
+    }
+
+    public ThreadDownloadImageData obtainImageData(String s, ImageBuffer imagebuffer) {
+        ThreadDownloadImageData threaddownloadimagedata = (ThreadDownloadImageData) urlToImageDataMap.get(s);
+        if (threaddownloadimagedata == null) {
+            urlToImageDataMap.put(s, new ThreadDownloadImageData(s, imagebuffer));
+        } else {
+            threaddownloadimagedata.referenceCount++;
+        }
+        return threaddownloadimagedata;
+    }
+
+    public void releaseImageData(String s) {
+        ThreadDownloadImageData threaddownloadimagedata = (ThreadDownloadImageData) urlToImageDataMap.get(s);
+        if (threaddownloadimagedata != null) {
+            threaddownloadimagedata.referenceCount--;
+            if (threaddownloadimagedata.referenceCount == 0) {
+                if (threaddownloadimagedata.textureName >= 0) {
+                    deleteTexture(threaddownloadimagedata.textureName);
+                }
+                urlToImageDataMap.remove(s);
+            }
+        }
+    }
+
+    public void registerTextureFX(TextureFX texturefx) {
+        field_1604_f.add(texturefx);
+        texturefx.func_783_a();
     }
 
     public void func_1067_a() {
-        int var1;
-        TextureFX var2;
-        int var3;
-        int var4;
-        int var5;
-        int var6;
-        int var7;
-        int var8;
-        int var9;
-        int var10;
-        int var11;
-        int var12;
-        for(var1 = 0; var1 < this.field_1604_f.size(); ++var1) {
-            var2 = (TextureFX)this.field_1604_f.get(var1);
-            var2.field_1131_c = this.options.anaglyph;
-            var2.func_783_a();
-            this.imageData.clear();
-            this.imageData.put(var2.field_1127_a);
-            this.imageData.position(0).limit(var2.field_1127_a.length);
-            var2.func_782_a(this);
-
-            for(var3 = 0; var3 < var2.field_1129_e; ++var3) {
-                for(var4 = 0; var4 < var2.field_1129_e; ++var4) {
-                    GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, var2.field_1126_b % 16 * 16 + var3 * 16, var2.field_1126_b / 16 * 16 + var4 * 16, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
-                    if(useMipmaps) {
-                        for(var5 = 1; var5 <= 4; ++var5) {
-                            var6 = 16 >> var5 - 1;
-                            var7 = 16 >> var5;
-
-                            for(var8 = 0; var8 < var7; ++var8) {
-                                for(var9 = 0; var9 < var7; ++var9) {
-                                    var10 = this.imageData.getInt((var8 * 2 + 0 + (var9 * 2 + 0) * var6) * 4);
-                                    var11 = this.imageData.getInt((var8 * 2 + 1 + (var9 * 2 + 0) * var6) * 4);
-                                    var12 = this.imageData.getInt((var8 * 2 + 1 + (var9 * 2 + 1) * var6) * 4);
-                                    int var13 = this.imageData.getInt((var8 * 2 + 0 + (var9 * 2 + 1) * var6) * 4);
-                                    int var14 = this.averageColor(this.averageColor(var10, var11), this.averageColor(var12, var13));
-                                    this.imageData.putInt((var8 + var9 * var7) * 4, var14);
-                                }
-                            }
-
-                            GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, var5, var2.field_1126_b % 16 * var7, var2.field_1126_b / 16 * var7, var7, var7, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, this.imageData);
-                        }
-                    }
-                }
-            }
-        }
-
-        for(var1 = 0; var1 < this.field_1604_f.size(); ++var1) {
-            var2 = (TextureFX)this.field_1604_f.get(var1);
-            if(var2.field_1130_d > 0) {
-                this.imageData.clear();
-                this.imageData.put(var2.field_1127_a);
-                this.imageData.position(0).limit(var2.field_1127_a.length);
-                GL11.glBindTexture(GL11.GL_TEXTURE_2D, var2.field_1130_d);
-                GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, 0, 0, 0, 16, 16, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
-                if(useMipmaps) {
-                    for(var3 = 1; var3 <= 4; ++var3) {
-                        var4 = 16 >> var3 - 1;
-                        var5 = 16 >> var3;
-
-                        for(var6 = 0; var6 < var5; ++var6) {
-                            for(var7 = 0; var7 < var5; ++var7) {
-                                var8 = this.imageData.getInt((var6 * 2 + 0 + (var7 * 2 + 0) * var4) * 4);
-                                var9 = this.imageData.getInt((var6 * 2 + 1 + (var7 * 2 + 0) * var4) * 4);
-                                var10 = this.imageData.getInt((var6 * 2 + 1 + (var7 * 2 + 1) * var4) * 4);
-                                var11 = this.imageData.getInt((var6 * 2 + 0 + (var7 * 2 + 1) * var4) * 4);
-                                var12 = this.averageColor(this.averageColor(var8, var9), this.averageColor(var10, var11));
-                                this.imageData.putInt((var6 + var7 * var5) * 4, var12);
-                            }
-                        }
-
-                        GL11.glTexSubImage2D(GL11.GL_TEXTURE_2D, var3, 0, 0, var5, var5, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)this.imageData);
-                    }
-                }
-            }
-        }
-
-    }
-
-    private int averageColor(int var1, int var2) {
-        int var3 = (var1 & -16777216) >> 24 & 255;
-        int var4 = (var2 & -16777216) >> 24 & 255;
-        return (var3 + var4 >> 1 << 24) + ((var1 & 16711422) + (var2 & 16711422) >> 1);
-    }
-
-    private int weightedAverageColor(int var1, int var2) {
-        int var3 = (var1 & -16777216) >> 24 & 255;
-        int var4 = (var2 & -16777216) >> 24 & 255;
-        short var5 = 255;
-        if(var3 + var4 == 0) {
-            var3 = 1;
-            var4 = 1;
-            var5 = 0;
-        }
-
-        int var6 = (var1 >> 16 & 255) * var3;
-        int var7 = (var1 >> 8 & 255) * var3;
-        int var8 = (var1 & 255) * var3;
-        int var9 = (var2 >> 16 & 255) * var4;
-        int var10 = (var2 >> 8 & 255) * var4;
-        int var11 = (var2 & 255) * var4;
-        int var12 = (var6 + var9) / (var3 + var4);
-        int var13 = (var7 + var10) / (var3 + var4);
-        int var14 = (var8 + var11) / (var3 + var4);
-        return var5 << 24 | var12 << 16 | var13 << 8 | var14;
+        for (int i = 0; i < field_1604_f.size(); i++) {
+            TextureFX texturefx = (TextureFX) field_1604_f.get(i);
+            texturefx.field_1131_c = options.anaglyph;
+            texturefx.func_783_a();
+            imageData.clear();
+            imageData.put(texturefx.field_1127_a);
+            imageData.position(0).limit(texturefx.field_1127_a.length);
+            texturefx.func_782_a(this);
+            for (int k = 0; k < texturefx.field_1129_e; k++) {
+                label0:
+                for (int i1 = 0; i1 < texturefx.field_1129_e; i1++) {
+                    GL11.glTexSubImage2D(3553 /*GL_TEXTURE_2D*/, 0, (texturefx.field_1126_b % 16) * 16 + k * 16, (texturefx.field_1126_b / 16) * 16 + i1 * 16, 16, 16, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+                    if (!useMipmaps) {
+                        continue;
+                    }
+                    int k1 = 1;
+                    do {
+                        if (k1 > 4) {
+                            continue label0;
+                        }
+                        int i2 = 16 >> k1 - 1;
+                        int k2 = 16 >> k1;
+                        for (int i3 = 0; i3 < k2; i3++) {
+                            for (int k3 = 0; k3 < k2; k3++) {
+                                int i4 = imageData.getInt((i3 * 2 + (k3 * 2) * i2) * 4);
+                                int k4 = imageData.getInt((i3 * 2 + 1 + (k3 * 2) * i2) * 4);
+                                int i5 = imageData.getInt((i3 * 2 + 1 + (k3 * 2 + 1) * i2) * 4);
+                                int k5 = imageData.getInt((i3 * 2 + (k3 * 2 + 1) * i2) * 4);
+                                int l5 = averageColor(averageColor(i4, k4), averageColor(i5, k5));
+                                imageData.putInt((i3 + k3 * k2) * 4, l5);
+                            }
+
+                        }
+
+                        GL11.glTexSubImage2D(3553 /*GL_TEXTURE_2D*/, k1, (texturefx.field_1126_b % 16) * k2, (texturefx.field_1126_b / 16) * k2, k2, k2, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+                        k1++;
+                    } while (true);
+                }
+
+            }
+
+        }
+
+        label1:
+        for (int j = 0; j < field_1604_f.size(); j++) {
+            TextureFX texturefx1 = (TextureFX) field_1604_f.get(j);
+            if (texturefx1.field_1130_d <= 0) {
+                continue;
+            }
+            imageData.clear();
+            imageData.put(texturefx1.field_1127_a);
+            imageData.position(0).limit(texturefx1.field_1127_a.length);
+            GL11.glBindTexture(3553 /*GL_TEXTURE_2D*/, texturefx1.field_1130_d);
+            GL11.glTexSubImage2D(3553 /*GL_TEXTURE_2D*/, 0, 0, 0, 16, 16, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+            if (!useMipmaps) {
+                continue;
+            }
+            int l = 1;
+            do {
+                if (l > 4) {
+                    continue label1;
+                }
+                int j1 = 16 >> l - 1;
+                int l1 = 16 >> l;
+                for (int j2 = 0; j2 < l1; j2++) {
+                    for (int l2 = 0; l2 < l1; l2++) {
+                        int j3 = imageData.getInt((j2 * 2 + (l2 * 2) * j1) * 4);
+                        int l3 = imageData.getInt((j2 * 2 + 1 + (l2 * 2) * j1) * 4);
+                        int j4 = imageData.getInt((j2 * 2 + 1 + (l2 * 2 + 1) * j1) * 4);
+                        int l4 = imageData.getInt((j2 * 2 + (l2 * 2 + 1) * j1) * 4);
+                        int j5 = averageColor(averageColor(j3, l3), averageColor(j4, l4));
+                        imageData.putInt((j2 + l2 * l1) * 4, j5);
+                    }
+
+                }
+
+                GL11.glTexSubImage2D(3553 /*GL_TEXTURE_2D*/, l, 0, 0, l1, l1, 6408 /*GL_RGBA*/, 5121 /*GL_UNSIGNED_BYTE*/, imageData);
+                l++;
+            } while (true);
+        }
+
+    }
+
+    private int averageColor(int i, int j) {
+        int k = (i & 0xff000000) >> 24 & 0xff;
+        int l = (j & 0xff000000) >> 24 & 0xff;
+        return ((k + l >> 1) << 24) + ((i & 0xfefefe) + (j & 0xfefefe) >> 1);
+    }
+
+    private int weightedAverageColor(int i, int j) {
+        int k = (i & 0xff000000) >> 24 & 0xff;
+        int l = (j & 0xff000000) >> 24 & 0xff;
+        char c = '\377';
+        if (k + l == 0) {
+            k = 1;
+            l = 1;
+            c = '\0';
+        }
+        int i1 = (i >> 16 & 0xff) * k;
+        int j1 = (i >> 8 & 0xff) * k;
+        int k1 = (i & 0xff) * k;
+        int l1 = (j >> 16 & 0xff) * l;
+        int i2 = (j >> 8 & 0xff) * l;
+        int j2 = (j & 0xff) * l;
+        int k2 = (i1 + l1) / (k + l);
+        int l2 = (j1 + i2) / (k + l);
+        int i3 = (k1 + j2) / (k + l);
+        return c << 24 | k2 << 16 | l2 << 8 | i3;
     }
 
     public void refreshTextures() {
-        TexturePackBase var1 = this.field_6527_k.selectedTexturePack;
-        Iterator var2 = this.textureNameToImageMap.keySet().iterator();
-
-        BufferedImage var4;
-        while(var2.hasNext()) {
-            int var3 = ((Integer)var2.next()).intValue();
-            var4 = (BufferedImage)this.textureNameToImageMap.get(Integer.valueOf(var3));
-            this.setupTexture(var4, var3);
-        }
-
-        ThreadDownloadImageData var7;
-        for(var2 = this.urlToImageDataMap.values().iterator(); var2.hasNext(); var7.textureSetupComplete = false) {
-            var7 = (ThreadDownloadImageData)var2.next();
-        }
-
-        var2 = this.textureMap.keySet().iterator();
-
-        while(var2.hasNext()) {
-            String var8 = (String)var2.next();
-
+        TexturePackBase texturepackbase = field_6527_k.selectedTexturePack;
+        int i;
+        BufferedImage bufferedimage;
+        for (Iterator iterator = textureNameToImageMap.keySet().iterator(); iterator.hasNext(); setupTexture(bufferedimage, i)) {
+            i = ((Integer) iterator.next()).intValue();
+            bufferedimage = (BufferedImage) textureNameToImageMap.get(Integer.valueOf(i));
+        }
+
+        for (Iterator iterator1 = urlToImageDataMap.values().iterator(); iterator1.hasNext(); ) {
+            ThreadDownloadImageData threaddownloadimagedata = (ThreadDownloadImageData) iterator1.next();
+            threaddownloadimagedata.textureSetupComplete = false;
+        }
+
+        for (Iterator iterator2 = textureMap.keySet().iterator(); iterator2.hasNext(); ) {
+            String s = (String) iterator2.next();
             try {
-                if(var8.startsWith("##")) {
-                    var4 = this.unwrapImageByColumns(this.readTextureImage(var1.func_6481_a(var8.substring(2))));
-                } else if(var8.startsWith("%clamp%")) {
-                    this.clampTexture = true;
-                    var4 = this.readTextureImage(var1.func_6481_a(var8.substring(7)));
-                } else if(var8.startsWith("%blur%")) {
-                    this.blurTexture = true;
-                    var4 = this.readTextureImage(var1.func_6481_a(var8.substring(6)));
+                BufferedImage bufferedimage1;
+                if (s.startsWith("##")) {
+                    bufferedimage1 = unwrapImageByColumns(readTextureImage(texturepackbase.func_6481_a(s.substring(2))));
+                } else if (s.startsWith("%clamp%")) {
+                    clampTexture = true;
+                    bufferedimage1 = readTextureImage(texturepackbase.func_6481_a(s.substring(7)));
+                } else if (s.startsWith("%blur%")) {
+                    blurTexture = true;
+                    bufferedimage1 = readTextureImage(texturepackbase.func_6481_a(s.substring(6)));
                 } else {
-                    var4 = this.readTextureImage(var1.func_6481_a(var8));
+                    bufferedimage1 = readTextureImage(texturepackbase.func_6481_a(s));
                 }
-
-                int var5 = ((Integer)this.textureMap.get(var8)).intValue();
-                this.setupTexture(var4, var5);
-                this.blurTexture = false;
-                this.clampTexture = false;
-            } catch (IOException var6) {
-                var6.printStackTrace();
+                int j = ((Integer) textureMap.get(s)).intValue();
+                setupTexture(bufferedimage1, j);
+                blurTexture = false;
+                clampTexture = false;
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
             }
         }
 
     }
 
-    private BufferedImage readTextureImage(InputStream var1) throws IOException {
-        BufferedImage var2 = ImageIO.read(var1);
-        var1.close();
-        return var2;
+    private BufferedImage readTextureImage(InputStream inputstream) throws IOException {
+        BufferedImage bufferedimage = ImageIO.read(inputstream);
+        inputstream.close();
+        return bufferedimage;
     }
 
-    public void bindTexture(int var1) {
-        if(var1 >= 0) {
-            GL11.glBindTexture(GL11.GL_TEXTURE_2D, var1);
+    public void bindTexture(int i) {
+        if (i < 0) {
+        } else {
+            GL11.glBindTexture(3553 /*GL_TEXTURE_2D*/, i);
         }
     }
+
 }
